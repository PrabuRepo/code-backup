package com.utube.ideserve.problems;

import com.common.model.TreeNode;

public class TreeProblems {
	// Lowest Common Ancestor
	public void lowestCommonAncestor(TreeNode root) {

	}

	// Create a balanced Binary Search Tree (BST) from a sorted array
	public TreeNode constructBST(int[] arr) {
		return null;
	}

	// Minimum Depth of Binary Tree
	public int minimumDepthOfBinaryTree(TreeNode root) {
		return 0;
	}

	// Find Nth largest element from a given binary search tree
	public int nthLargestElementOfBST(TreeNode root) {
		return 0;
	}

	// How to print all diagonal's sums for a given binary tree
	public int diagonalSumOfBinaryTree(TreeNode root) {
		return 0;
	}

	// Recover Binary Search Tree
	public int recoverBinarySearchTree(TreeNode root) {
		return 0;
	}

	// Total number of unique binary search trees with values 1 to n
	public int uniqueBST(TreeNode root) {
		return 0;
	}

	// Populate next right pointers in a binary tree
	public void nextRightPointers(TreeNode root) {

	}

	// Spiral level order traversal of a binary tree
	public void spiralLevelOrderTraversal(TreeNode root) {

	}

	// Check if Binary Tree is Symmetric or Not
	public boolean isSymmetric(TreeNode root) {
		return false;
	}

	// Converting Bin Tree to BST without changing spatial structure
	public void convertBinToBST(TreeNode root) {

	}

	// Check if binary tree is balanced
	public boolean isBTBalanced(TreeNode root) {
		return false;
	}

	// Serialize and Deserialize a Binary Search Tree
	public void serializeBST1(TreeNode root) {

	}

	public void deSerializeBST1(TreeNode root) {

	}

	// Serialize and Deserialize a Binary Search Tree in O(n) time
	public void serializeBST2(TreeNode root) {

	}

	public void deSerializeBST2(TreeNode root) {

	}

	// Serialize and Deserialize a Binary Tree
	public void serializeBT(TreeNode root) {

	}

	public void deSerializeBT(TreeNode root) {

	}

	// Level Order Traversal
	public void levelOrderTraversal(TreeNode root) {

	}
	// Trie Insert and Search

}
